<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>내 손안의 마리짱</title>
  <link rel="icon" type="image/png" href="./src/fav.png">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #000;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    }

    canvas { display: block; touch-action: none; }

    /* 카메라 배경 */
    #camera-bg {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: -1;
    }

    #loading {
      position: fixed;
      inset: 0;
      background: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      z-index: 100;
    }

    #loading-bar-wrap {
      width: 200px;
      height: 2px;
      background: #eee;
      border-radius: 2px;
      overflow: hidden;
    }

    #loading-bar {
      height: 100%;
      background: #111;
      width: 0%;
      border-radius: 2px;
      transition: width 0.3s ease;
    }

    @keyframes pulse {
      0%   { opacity: 1; }
      50%  { opacity: 0.4; }
      100% { opacity: 1; }
    }

    #loading p {
      font-size: 12px;
      color: #aaa;
      letter-spacing: 0.1em;
      animation: pulse 1.5s ease infinite;
    }

    #hint {
      position: fixed;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 11px;
      color: rgba(255, 255, 255, 0.85);
      text-shadow: 0 1px 6px rgba(0, 0, 0, 0.6);
      letter-spacing: 0.1em;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.8s;
      text-align: center;
    }

    #hint.show { opacity: 1; }
  </style>
</head>
<body>

<!-- 카메라 배경 -->
<video id="camera-bg" autoplay playsinline muted></video>

<div id="loading">
  <div id="loading-bar-wrap">
    <div id="loading-bar"></div>
  </div>
  <p>LOADING</p>
</div>

<div id="hint">귀여운 마리짱을 손가락으로<br> 요리조리 돌려보세요.<br>크게 볼 수도 있어요!</div>

<!-- Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- GLTFLoader -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
  // ── Scene ──────────────────────────────────────────────────────────────────
  const scene = new THREE.Scene();
  // 배경 투명 (카메라 영상이 보이게)

  // ── Camera ──
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
  camera.position.set(-0.2, 1, 3);
  camera.lookAt(0, 0, 0);

  // ── Renderer (투명 배경) ──
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setClearColor(0x000000, 0);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.physicallyCorrectLights = true;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  // ── Lights ──
  scene.add(new THREE.AmbientLight(0xffffff, 1));

  const dirLight = new THREE.DirectionalLight(0xffffff, 1.3);
  dirLight.position.set(3, 6, 4);
  dirLight.castShadow = true;
  scene.add(dirLight);

  const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
  fillLight.position.set(-3, -2, -3);
  scene.add(fillLight);

  const rimLight = new THREE.DirectionalLight(0xffffff, 0.25);
  rimLight.position.set(0, -4, -3);
  scene.add(rimLight);

  // ── Pivot (회전 그룹) ──
  const pivot = new THREE.Group();
  scene.add(pivot);

  // ── GLB 로드 ─────────────────────────────────────────────────────────────
  const loader = new THREE.GLTFLoader();

  loader.load(
    './model/mari_or.glb',
    (gltf) => {
      document.getElementById('loading-bar').style.width = '100%';
      setTimeout(() => {
        document.getElementById('loading').style.display = 'none';
      }, 300);

      const model = gltf.scene;

      const box    = new THREE.Box3().setFromObject(model);
      const center = box.getCenter(new THREE.Vector3());
      const size   = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);

      model.position.sub(center);
      model.position.y += 0.5;
      model.scale.setScalar(1.4 / maxDim);

      pivot.add(model);

      rotY = -0.5;

      const hint = document.getElementById('hint');
      hint.classList.add('show');
    },
    (xhr) => {
      if (xhr.total > 0) {
        const pct = (xhr.loaded / xhr.total * 100).toFixed(0);
        document.getElementById('loading-bar').style.width = pct + '%';
      } else {
        document.getElementById('loading-bar').style.transition = 'none';
        document.getElementById('loading-bar').style.width = '40%';
      }
    },
    (err) => {
      console.error('GLB 로드 실패:', err);
      document.getElementById('loading').innerHTML =
        '<p style="color:#e00;font-size:14px;">모델 로드 실패<br><small style="color:#aaa">콘솔을 확인해주세요</small></p>';
    }
  );

  // ── 터치/마우스 컨트롤 ──────────────────────────────────────────────────────
  let isDragging = false;
  let prevX = 0, prevY = 0;
  let rotX = 0, rotY = 0;
  let velX = 0, velY = 0;

  let prevPinchDist = null;
  let prevPanX = 0, prevPanY = 0;
  let isPanning = false;
  let currentScale = 1;

  const canvas = renderer.domElement;

  // Mouse
  canvas.addEventListener('mousedown', e => {
    isDragging = true;
    prevX = e.clientX; prevY = e.clientY;
    velX = 0; velY = 0;
  });
  window.addEventListener('mousemove', e => {
    if (!isDragging) return;
    const dx = e.clientX - prevX;
    const dy = e.clientY - prevY;
    velX = dx; velY = dy;
    rotY += dx * 0.005;
    rotX += dy * 0.005;
    rotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotX));
    prevX = e.clientX; prevY = e.clientY;
  });
  window.addEventListener('mouseup', () => { isDragging = false; });

  // Touch
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if (e.touches.length === 1) {
      isDragging = true;
      isPanning = false;
      prevX = e.touches[0].clientX;
      prevY = e.touches[0].clientY;
      velX = 0; velY = 0;
    }
    if (e.touches.length === 2) {
      isDragging = false;
      isPanning = true;
      prevPinchDist = getPinchDist(e);
      prevPanX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
      prevPanY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', e => {
    e.preventDefault();

    if (e.touches.length === 1 && isDragging) {
      const dx = e.touches[0].clientX - prevX;
      const dy = e.touches[0].clientY - prevY;
      velX = dx; velY = dy;
      rotY += dx * 0.006;
      rotX += dy * 0.006;
      rotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotX));
      prevX = e.touches[0].clientX;
      prevY = e.touches[0].clientY;
    }

    if (e.touches.length === 2) {
      const dist = getPinchDist(e);
      if (prevPinchDist !== null) {
        const delta = dist / prevPinchDist;
        currentScale = Math.max(0.3, Math.min(5, currentScale * delta));
        pivot.scale.setScalar(currentScale);
      }
      prevPinchDist = dist;

      const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
      const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
      const panDx = cx - prevPanX;
      const panDy = cy - prevPanY;
      pivot.position.x += panDx * 0.004;
      pivot.position.y -= panDy * 0.004;
      prevPanX = cx;
      prevPanY = cy;
    }
  }, { passive: false });

  canvas.addEventListener('touchend', e => {
    if (e.touches.length < 2) { prevPinchDist = null; isPanning = false; }
    if (e.touches.length === 0) isDragging = false;
    if (e.touches.length === 1) {
      isDragging = true;
      prevX = e.touches[0].clientX;
      prevY = e.touches[0].clientY;
    }
  });

  canvas.addEventListener('wheel', e => {
    currentScale = Math.max(0.3, Math.min(5, currentScale - e.deltaY * 0.001));
    pivot.scale.setScalar(currentScale);
  });

  function getPinchDist(e) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // ── 리사이즈 ──
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // ── 애니메이션 루프 ──
  function animate() {
    requestAnimationFrame(animate);

    if (!isDragging) {
      velX *= 0.92;
      velY *= 0.92;
      rotY += velX * 0.003;
      rotX += velY * 0.003;
    }

    pivot.rotation.x = rotX;
    pivot.rotation.y = rotY;

    renderer.render(scene, camera);
  }
  animate();

  // ── 후면 카메라 켜기 ──
  navigator.mediaDevices.getUserMedia({
    video: { facingMode: 'environment' }
  })
  .then(stream => {
    document.getElementById('camera-bg').srcObject = stream;
  })
  .catch(() => {
    // 카메라 거부 시 흰 배경으로 대체
    document.body.style.background = '#ffffff';
  });
</script>
</body>
</html>
